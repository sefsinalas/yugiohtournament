<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Tournament</title>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/picnic">
<style>
 body {
  font-family: Arial, sans-serif;
  margin: 20px;
  background: #f6f6f6;
 }

 .container {
  max-width: 1000px;
  margin: auto;
  display: flex;
  gap: 20px;
 }

 #leftPane { flex: 2; }
 #rightPane { flex: 1; }

 #rightPane table {
  width: 100%;
  border-collapse: collapse;
 }

 #rightPane th, #rightPane td {
  border-bottom: 1px solid #ddd;
  padding: 4px;
  text-align: left;
 }

h1 {
 text-align: center;
 margin-bottom: 20px;
}

h2 {
  margin-top: 0;
  margin-bottom: 10px;
  text-align: center;
}

 #timer {
  font-size: 2.5em;
  text-align: center;
  margin-bottom: 20px;
 }

 button {
  margin-right: 10px;
  margin-top: 5px;
 }

 ul {
  list-style-type: none;
  padding-left: 0;
 }

 li {
  padding: 8px 0;
  border-bottom: 1px solid #ddd;
 }

 li:last-child {
  border-bottom: none;
 }
</style>
</head>
<body>
<div class="container">
<div id="leftPane">
<h1>Tournament</h1>
<section class="card">
<div id="timer"></div>
<button id="simulate">Simulate tournamente</button>
<button id="newTournament" disabled>Start a New Tournament</button>
<button id="startRound" class="success" disabled>Start Round 1</button>
</section>
<h2>Simulation</h2>
<section class="card" id="simulationSection" style="display:none"></section>
<div id="roundsContainer"></div>
</div>
<div id="rightPane" class="card">
<h2>Tabla de Posiciones</h2>
<table id="scoreTable">
<thead>
<tr><th>#</th><th>Nombre</th><th>Puntos</th></tr>
</thead>
<tbody id="scoreTableBody"></tbody>
</table>
</div>
<script>
const PARTICIPANTS_KEY = 'participants';
const STARTED_KEY = 'tournamentStarted';
const SIMULATED_KEY = 'tournamentSimulated';

let totalRounds = 0;
let currentRound = 0;
let pairings = {};
let results = {};
let scores = {};

function loadParticipants() {
  const data = localStorage.getItem(PARTICIPANTS_KEY);
  if (!data) return [];
  try { return JSON.parse(data); } catch (e) { return []; }
}

function savePairings() {}

function loadResults() { return {}; }

function saveResults() {}

function loadScores() { return {}; }

function saveScores() {}

function getStarted() {
  return localStorage.getItem(STARTED_KEY) === 'true';
}

function setStarted(val) {
  localStorage.setItem(STARTED_KEY, val ? 'true' : 'false');
}

function getSimulated() {
  return localStorage.getItem(SIMULATED_KEY) === 'true';
}

function setSimulated(val) {
  localStorage.setItem(SIMULATED_KEY, val ? 'true' : 'false');
}

function randomizePairingsList(participants) {
  const shuffled = [...participants];
  for (let i = shuffled.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
  }
  const pairings = [];
  for (let i = 0; i < shuffled.length; i += 2) {
    const p1 = shuffled[i];
    const p2 = shuffled[i + 1] || { name: 'BYE' };
    pairings.push({ p1: p1.name, p2: p2.name });
  }
  return pairings;
}

function swissPairings() {
  const players = participants.map(p => p.name).sort((a, b) => (scores[b] || 0) - (scores[a] || 0));
  const out = [];
  for (let i = 0; i < players.length; i += 2) {
    const p1 = players[i];
    const p2 = players[i + 1] || 'BYE';
    out.push({ p1, p2 });
  }
  return out;
}

function displayPairings(roundPairings, round) {
  const list = document.getElementById('pairingsList' + round);
  list.innerHTML = '';
  roundPairings.forEach((p, idx) => {
    const li = document.createElement('li');
    li.textContent = `${idx + 1}. ${p.p1} vs ${p.p2}`;
    list.appendChild(li);
  });
}

function displayResults(roundPairings, roundResults, round) {
  const container = document.getElementById('resultsSection' + round);
  container.innerHTML = '';
  roundPairings.forEach((p, idx) => {
    const div = document.createElement('div');
    const label = document.createElement('span');
    label.textContent = `Match ${idx + 1}: `;
    div.appendChild(label);

    const b1 = document.createElement('button');
    b1.textContent = p.p1;
    const b2 = document.createElement('button');
    b2.textContent = p.p2;
    const draw = document.createElement('button');
    draw.textContent = 'Draw';

    const outcome = roundResults[idx];
    if (outcome === 'p1') {
      b1.classList.add('success');
    } else if (outcome === 'p2') {
      b2.classList.add('success');
    } else if (outcome === 'draw') {
      draw.classList.add('success');
    }

    b1.addEventListener('click', () => recordResult(round, idx, 'p1'));
    b2.addEventListener('click', () => recordResult(round, idx, 'p2'));
    draw.addEventListener('click', () => recordResult(round, idx, 'draw'));

    div.appendChild(b1);
    div.appendChild(b2);
    div.appendChild(draw);
    container.appendChild(div);
  });
}

function displayScores(scores) {
  const body = document.getElementById('scoreTableBody');
  body.innerHTML = '';
  const entries = Object.entries(scores).sort((a, b) => b[1] - a[1]);
  entries.forEach(([name, pts], idx) => {
    const tr = document.createElement('tr');
    const pos = document.createElement('td');
    pos.textContent = idx + 1;
    const nm = document.createElement('td');
    nm.textContent = name;
    const sc = document.createElement('td');
    sc.textContent = pts;
    tr.appendChild(pos);
    tr.appendChild(nm);
    tr.appendChild(sc);
    body.appendChild(tr);
  });
}

function updateScores() {
  scores = {};
  for (let r = 1; r <= currentRound; r++) {
    const pr = pairings[r] || [];
    pr.forEach((p, idx) => {
      if (!scores[p.p1]) scores[p.p1] = 0;
      if (!scores[p.p2]) scores[p.p2] = 0;
      const res = (results[r] || {})[idx];
      if (res === 'p1') {
        scores[p.p1] += 3;
      } else if (res === 'p2') {
        scores[p.p2] += 3;
      } else if (res === 'draw') {
        scores[p.p1] += 1;
        scores[p.p2] += 1;
      }
    });
  }
  displayScores(scores);
}

function recordResult(round, index, outcome) {
  if (!results[round]) results[round] = {};
  results[round][index] = outcome;
  updateScores();
  displayResults(pairings[round], results[round], round);
  checkRoundCompletion(round);
}

function startTimer(duration) {
  const timer = document.getElementById('timer');
  let remaining = duration;
  timer.textContent = formatTime(remaining);
  const interval = setInterval(() => {
    remaining--;
    timer.textContent = formatTime(remaining);
    if (remaining <= 0) {
      clearInterval(interval);
    }
  }, 1000);
}

function formatTime(seconds) {
  const m = Math.floor(seconds / 60).toString().padStart(2, '0');
  const s = (seconds % 60).toString().padStart(2, '0');
  return `${m}:${s}`;
}

function swissRounds(players) {
  return Math.ceil(Math.log2(players));
}

function formatDuration(minutes) {
  const h = Math.floor(minutes / 60);
  const m = minutes % 60;
  return h > 0 ? `${h}h ${m}m` : `${m}m`;
}

function simulateTournament() {
  const section = document.getElementById('simulationSection');
  totalRounds = swissRounds(participants.length);
  const totalMinutes = totalRounds * (45 + 5);
  section.innerHTML = `Number of rounds: ${totalRounds}<br>Estimated time: ${formatDuration(totalMinutes)}`;
  section.style.display = 'block';
  setSimulated(true);
  document.getElementById('newTournament').disabled = false;
}

const participants = loadParticipants();

function initialize() {
  if (!getSimulated()) {
    document.getElementById('newTournament').disabled = true;
  }
  displayScores({});
}

initialize();

function createRoundSections() {
  const container = document.getElementById('roundsContainer');
  container.innerHTML = '';
  for (let i = 1; i <= totalRounds; i++) {
    const h = document.createElement('h2');
    h.textContent = `Round ${i}`;
    const pairS = document.createElement('section');
    pairS.className = 'card';
    const ul = document.createElement('ul');
    ul.id = `pairingsList${i}`;
    pairS.appendChild(ul);
    const resS = document.createElement('section');
    resS.className = 'card';
    resS.id = `resultsSection${i}`;
    if (i !== 1) {
      pairS.style.display = 'none';
      resS.style.display = 'none';
    }
    container.appendChild(h);
    container.appendChild(pairS);
    container.appendChild(resS);
  }
}

document.getElementById('simulate').addEventListener('click', simulateTournament);

document.getElementById('newTournament').addEventListener('click', () => {
  if (!getSimulated()) return;
  pairings = {};
  results = {};
  scores = {};
  currentRound = 0;
  displayScores(scores);
  createRoundSections();
  document.getElementById('startRound').disabled = false;
  document.getElementById('startRound').textContent = 'Start Round 1';
});

document.getElementById('startRound').addEventListener('click', () => {
  if (currentRound >= totalRounds) return;
  currentRound++;
  setStarted(true);
  let pr = currentRound === 1 ? randomizePairingsList(participants) : swissPairings();
  pairings[currentRound] = pr;
  results[currentRound] = {};
  displayPairings(pr, currentRound);
  displayResults(pr, results[currentRound], currentRound);
  document.getElementById('startRound').disabled = true;
  startTimer(45 * 60);
});

function checkRoundCompletion(round) {
  if (Object.keys(results[round]).length === pairings[round].length) {
    setStarted(false);
    if (round < totalRounds) {
      const next = round + 1;
      document.getElementById('startRound').disabled = false;
      document.getElementById('startRound').textContent = `Start Round ${next}`;
      const pairSec = document.getElementById('pairingsList' + next).parentElement;
      const resSec = document.getElementById('resultsSection' + next);
      pairSec.style.display = 'block';
      resSec.style.display = 'block';
    } else {
      document.getElementById('startRound').disabled = true;
    }
  }
}
</script>
</div>
</body>
</html>
